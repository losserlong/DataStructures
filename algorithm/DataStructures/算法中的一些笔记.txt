完成删除节点的操作：
规定：
1）如果删除的节点是叶子节点，则删除该节点
2）如果删除的节点是非叶子节点，则删除该子树

思路
首先先处理：
考虑如果树是空树root，如果只有一个root节点，则等价于将二叉树置空。

然后再进行下面的操作
1. 因为我们的二叉树是单向的(像链表)，所以我们是判断当前节点的子节点是否是需要待删除的节点，而不能判断当前这个节点是不是待删除的节点
2. 如果当前节点的左子树不为空，并且当前节点的左子节点的编号就是待删除的节点，就将this.left=null(就将当前节点的左子节点置空即可，有点类似链表)；并且提前返回(结束递归  )
3. 如果当前节点的右子树不为空，并且当前节点的右子节点的编号就是待删除的节点，就将this.right=null(就将当前节点的右子节点置空即可，有点类似链表) 
4. 如果第2，3步都没删除该节点，那么我们就需要向左子树(也要判断左子树是否为空)进行递归删除
5. 如果2，3，4步都没有删除掉该节点，就像右子树进行递归删除


顺序存储二叉树(应用是在堆排序)
顺序存储二叉树的概念：
    顺序存储二叉树的特点：
        （1）顺序存储二叉树通常只考虑完全二叉树
        （2）第n个元素的左子节点为2*n+1
        （3）第n个元素的右子节点为2*n+2
        （4）第n个元素的父节点是(n-1)/2
        （5）n：表示二叉树中的第几个元素(按照0开始编号如图所示)
        [1,2,3,4,5,6,7] (想那个二叉树的图) 




线索化二叉树：
1）n个结点的二叉链表中含有n+1  【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为"线索"）

2）这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种

3）一个结点的前一个结点，称为前驱结点
4）一个结点的后一个结点，称为后继结点








线索化二叉树，其实就叶子节点的left指针和right指针充分利用起来，将前序遍历、中序遍历或者后序遍历遍历完之后
将某种遍历次序之后，将它的左指针指向前驱节点，右指针指向后继节点
(如果已经指向一棵子树了就不用指了,或者是第一个节点或者是最后的节点就不用指了)


（1）left指向的是左子树，也可能指向的是前驱节点，比如①节点的left指向的就是左子树，而⑩节点的left指向的就是前驱节点
（2）right指向的是右子树，也可能指向的是后继节点，比如①节点的right指向的就是右子树，而⑩节点的right指向的就是后继节点


======赫夫曼树
基本介绍
1. 1给定 n 个 权值 作为 n 个 叶子节点，构造一颗二叉树，若该树的带权路径长度（WPL）达到最小，称这样的二叉树为 最优二叉树，也称为 哈夫曼树（Huffman Tree），还有的叫 霍夫曼树
2. 赫夫曼树是带全路径长度最短的树，权值较大的节点离根节点较近
重要概念
路径 和 路径长度：
在一颗树中，从一个节点往下可以到达的孩子或孙子节点之间的通路，称为 路径。

通路中分支的数目称为路径长度。若规定根节点的层数为 1，则从根节点到第 L 层节点的路径长度为 L-1。

节点的权 及 带权路径长度

若将树中节点赋给一个有着某种函数的数值，则这个数值称为该节点的 权。
节点的带权路径长度为：从根节点到该节点之间的路径长度与该节点的权的乘积。

树的带权路径长度
所有叶子节点的带权路径长度之和，记为 WPL（weighted path length），权值越大的节点离根节点越近的二叉树才是最优二叉树

WPL 最小的就是赫夫曼树

权：元素的值

路径长度：一个节点到另一个节点的一段路，就叫路径长度

带权路径长度：从根节点到 13 有几条路径长度，则是他的带权路径长度

树的带权路径长度：（图上的带全路径长度所指的是 树的带全路径长度）

                        





 =====二叉排序树节点的删除
     [7, 3, 10, 12, 5, 1, 9] 构建了一棵二叉排序树之后,插入2

                      7
                    /    \
                    3    10
                  /  \   / \   
                 1   5  9   12
                  \
                   2


     ===第一种情况：
     删除叶子节点(比如：2，5，9，12)
     思路
     （1）先去找到待删除的结点targetNode
     （2）找到targetNode结点的父节点parentNode（考虑是否存在父节点）
     （3）确定targetNode是parentNode结点的左子节点还是右子节点
     （4）根据前面的情况对应删除
     若是左子节点 parentNode.left=null
     若是右子节点 parentNode.right=null

     ===第二种情况：删除只有一棵子树的结点，比如1
     思路
     （1）先去查找待删除的结点targetNode (也就是1)
     （2）找到targetNode结点的父节点parentNode (也就是3)（考虑是否存在父节点） 
     （3）确定targetNode的子节点是左子节点还是右子节点
     （4）targetNode是parent的左子节点还是右子节点
 ===========================================思路一====================================    
     （5）如果targetNode是parent的左子节点
        5.1 targetNode的子节点是左子节点
        parent.left=targetNode.left;        
        5.2 targetNode的子节点是右子节点
        parent.left=targetNode.right;
 ====================================================================================    


        这里用的是思路二
 ===========================================思路二====================================    

     （5）如果targetNode有左子节点
        5.1 如果targetNode是parent的左子节点
        parent.left = targetNode.left;        
        5.2 如果targetNode是parent的右子节点
        parent.right = targetNode.left;

    （6）如果targetNode有右子节点
        6.1 如果targetNode是parent的左子节点
        parent.left = targetNode.right;        
        6.2 如果targetNode是parent的右子节点
        parent.right = targetNode.right;


    ===情况三：删除两棵子树的结点(比如：7，3，10)
    思路：
    （1）先去找到要删除的结点targetNode
    （2）找到targetNode的父节点
    （3）从targetNode的右子树找到最小的结点 (或者从左子树找,找到最大的数来替换待删除的结点的值)
    （4）用一个临时变量，将最小结点的值保存temp = 12
    （5）删除该最小值
    （6）targetNode.value = temp

                      7
                    /    \
                    3    10
                  /  \   / \            
                 1   5  9   12
                  \           \
                   2           11
                       ||
                       ||
                       ||
                       \/

                   删除10这个结点
                       7
                    /    \
                    3    11
                  /  \   / \            
                 1   5  9   12
                  \         
                   2                              
                  
========= 平衡二叉树值左旋转
       ======= 左旋转                                                  6
                                                                     / \
                4                                                   /   \
               / \                                                 /     \
              3   6                         左旋过后                4    6  \
                 / \                ====================>         / \ /  \ \
                5   7                                            3   5     7
                     \                                                     \
                      8                                                     8

        怎么进行左旋(6这个结点旋转过后就会被垃圾回收)
       1. 创建一个新的结点newNode(以4这个值创建一个新的结点,它的值等于当前节点的值)

        // 把新节点(newNode)的左子树设置当前节点的左子树
       2. newNode.left = this.left

        // 把新节点(newNode)的右子树设置为当前节点的右子树的左子树
       3. newNode.right = this.right.left

        // 把当前节点的值替换为右子节点的值
       4. value = right.value

        // 把当前节点的右子树设置为右子树的右子树
       5. right = right.right

       // 把当前节点的左子树设置为新结点(newNode)
       6. left = newLeft


========= 平衡二叉树值右旋转
       ======= 右旋转                                                       8
                                                                          / \
                    10                                                   /8  \
                   /  \                                                 //    10
                   8  12                右旋过后                         7     / \
                  / \               =============>                     / \   /  12
                 7   9                                                 6  \ /
                /                                                          9
               6
       当添加6这个结点之后就不是avl树了，因为leftHeight() - rightHeight() > 1

       右旋转就是降低左子树的高度，这里是将9这个结点通过右旋转到右子树
       1. 创建一个新的结点但newNode(以10这个值创建)，创建一个新的结点，值等于当前节点的值

       // 把新节点的右子树设置为当前结点的右子树
       2. newNode.right=right

       // 把新结点的左子树设置为当前节点的左子树的右子树
       3. newNode.left=left.right

       // 把当前节点的值替换成左子节点的值
       4. value=left.value

       // 把当前节点的左子树设置成左子树的左子树
       5. left=left.left

       // 把当前节点的右子树设置为新结点
       right=newLeft



========= 平衡二叉树值双旋转
       ======= 双旋转

            10                                            7
           /  \                                          / \
          7    11       右旋转后                          6  10
         / \            ==========>                        / \
        6   8                                             8   11
             \                                             \
              9                                             9

        问题分析
        1. 当符合右旋转的条件时
        2. 如果它的左子树的右子树高度大于右子树高度 (比如以7为根节点的左子树)
        3. 先对当前这个这个结点进行向左旋转，也就是降低当前节点的左子树的右子树的高度
        4. 再对当前节点进行向右旋转操作即可


=====图
图是一种 数据结构，其中节点可以具有 零个或多个相邻元素，两个节点之间的链接称为 边，节点页可以称为 顶点。
图的表示方法：
        1. 二维数组表示：邻接矩阵
        2. 链表表示：邻接表

左侧的 0~5 表示顶点（也就是列，竖看）
横着的 0 -5 表示，左侧的顶点，与其他顶点的关系
比如：0,0 的值为 0，则表示 不能直连 ，0-1 的值为 1，表示可用直连。
        用邻接矩阵来表示图
         *     A B C D E
         * A   0 1 1 0 0
         * B   1 1 0 0 0
         * C   0 1 0 0 0
         * D   0 1 0 0 0
         * E   0 1 0 0 0

邻接表：由于邻接矩阵有一个缺点：它需要为每个顶点都分配 n 个边的空间，
其实有很多边都是不存在的（比如上面的 0,0 不链接，也需要表示出来），这 会造成空间的一定损失。
而 邻接表 的实现只关心 存在的边，因此没有空间浪费，由 数组 + 链表组成。






==========图的深度优先遍历介绍
        图的深度优先搜索（Depth First Search），简称 DFS。
        深度优先遍历算法步骤 (其实树的前序中序后续遍历都是深度优先遍历算法)
        1. 访问初始节点v，并标记结点v为已访问
        2. 查找结点v的第一个邻接结点w
        3. 若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个节点继续 (其实就是递归的时候回退到上一个栈，也就是回溯)
        4. 若w未被访问，对w进行深度优先遍历递归(即把w当作另一个v，然后进行步骤123)
        5. 查找结点v的w邻接结点的下一个邻接结点，转到步骤3 (其实就是w已经被访问了)
                    B\
                   /| \\
                  / |  D\
                 C  |     E
                  \ |
                   \|
                    A


==========图的广度优先遍历介绍 (使用队列实现广度优先遍历,其实就是和树的层次遍历一样)
          图的广度优先搜索(Broad First Search)。
          类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，
          以便按这个顺序来访问这些结点的邻接结点。

          1. 访问初始节点v并标记节点v已经访问
          2. 节点v入队列
          3. 当队列非空时,继续执行,否则算法结束,就是这个栈结束
          4. 出队列,取得队头节点u
          5. 查找节点u的第一个邻接节点w
          6. 查找节点u的邻接节点w不存在,则转到步骤3;否侧循环执行以下三个步骤：
          6.1 若节点w尚未被访问,则访问节点w并标记为已访问
          6.2 节点w入队列
          6.3 查找节点u的继w邻接节点后的下一个邻接节点w,转移到步骤6




















    /*    // 当前节点的左子节点值等于value或者右子节点值等于value,就返回当前结点
        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {
            return this;
        } else {
            // 如果待查找的结点的值比当前结点的值小,并且当前节点的左子节点不为空,递归向左边查找
            if (value < this.left.value && this.left != null) {
                // 向左子树递归查找
                return this.left.searchParentNode(value);
            } else if (value >= this.right.value && this.right != null ) {
                // 这里 >= 因为是之前加的时候相等的值加在了右子树
                // 向右子树递归查找
                return this.right.searchParentNode(value);
            } else {
                // 当当前结点的左子节点为空或者,当前节点右子树为空
                // 就是除了上面那两种情况之外
                return null;

            }

        }*/